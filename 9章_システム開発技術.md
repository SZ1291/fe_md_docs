# 情報システム戦略

- IT による情報システムをどのように構築し、企業活動に活用していくのかという戦略
- **経営戦略に基づき**、組織全体における最適化(**全体最適化**)の観点から情報システムのあるべき姿を明確にすることが重要
- **システム管理基準** => 組織が経営戦略と情報システム戦略に基づき、情報システムの規格・開発・運用・保守などを効率的に行うための**実践規範**
- **IT ガバナンス** => **担当部門に任せきりでなく**、情報システム戦略の策定と実行をコントロールする**組織の能力**

# EA(エンタープライズアーキテクチャ)

- ビジネスアーキテクチャ => 経営戦略に必要な実現すべき**業務の姿**を体系化
- データアーキテクチャ => 業務に必要な**データの内容やデータ間の関連性**を体系化
- アプリケーションアーキテクチャ => 業務処理に必要な**情報システムの形態**を体系化
- テクノロジーアーキテクチャ => 情報システムの構築・運用に必要な**技術的要素**を体系化するもの
- **アプリケーションアーキとテクノロジアーキの混同注意！**(H31 春期 問 61)

# ソフトウェアライフサイクルプロセス

- 共通フレーム => システム開発に関係する人たちが同じ言葉で話せるように、共通の物差しとなるガイドライン
- レビュー
  - 各工程の終わりに開かれる検討会のこと
  - 仕様の不備や誤りを早期に発見して後戻りの工数削減を図る
  - レビュー技法
    - ラウンドロビン：参加者全員がテーマごとに進行役となる
    - ウォークスルー：レビュー対象物の作成者が説明者となり、複数の関係者が質問やコメントをする
    - インスペクション：進行役の議長(**モデレーター**)がコーディネートし、**参加者全員の役割を明確に**してチェックリストなどに基づいてコメントする

1. 企画プロセス
   - システム化構想 => 経営上のニーズや課題を確認し、業務と情報システムの将来像を明確にしたうえで全体最適化を図る
   - システム化計画 => システム化の基本方針を策定(**管理体制、開発スケジュール、概算コスト、費用対効果など**を検討)
2. 要件定義プロセス
   - システムの機能や性能を明確にする
   - 業務要件 => 日々の業務に必要な要件。業務手順、関係する組織の責任や権限、**システム開発で用いるプログラム言語に合わせた開発基準、標準の技術要件の作成**(R1 秋期 問 65)など
   - システム要件
     - 機能要件 => システムに必要な機能、必要なデータ項目、処理内容、ユーザインターフェースなど
     - 非機能要件 => システムに必要な性能、稼働時間、応答時間、セキリュティなど
   - 調達
     1. 【依頼元】情報提供依頼書(RFI)
     2. 【ベンダ】情報提供
     3. 【依頼元】提案依頼書(RFP)の作成と配布
     4. 【ベンダ】提案書・見積書の作成と提案
     5. 【依頼元】提案内容の比較評価・調達先の選定
     6. 【依頼元・ベンダ】契約締結・プロジェクト開始
     - RFI：システム化の目的や業務の内容を提示し、ベンダの実績や開発方法、情報技術動向などの情報提供を依頼
     - RFP：導入するシステムの基本方針や概要、実現すべき機能、調達条件などを提示し、提案書の提出を依頼
     - RFI と RFP は複数ベンダに向けて提示し、実績などの情報や提案書を判断材料にベンダを選定する
     - グリーン IT => CSR の一環。省エネや資源の有効活用など**環境への配慮を行っている情報通信機器を選定すること**。国などの機関ではグリーン IT を実践している製品やサービスを選ぶこと(**グリーン購入**)をグリーン購入法で義務付けられている
3. 開発プロセス
   1. システム要件定義(外部設計)
   - 開発者が利用者にヒアリング
   - システム化する目的や対象範囲(対象業務・対象部署)を明確化。システムに必要な機能や性能を定義
   - システムの応答時間や処理時間、信頼の目標値などを決定
   2. ソフトウェア要件定義(外部設計)
   - 開発者が利用者にヒアリング
   - 利用者視点からソフトウェアに要求される機能や性能を定義
   - [業務モデリング](#業務モデリング)や[ヒューマンインターフェース](#ヒューマンインターフェース)の設計
   3. システム設計(外部設計)
   - 開発者に視点からシステム要件をどのように実現すべきかを決定
   - ハードウェアやソフトウェア、手作業で実施する範囲を明確化
   - ハードウェア構成やソフトウェア構成、システムの処理方式、使用するデータベースの種類などを決定
   4. ソフトウェア設計(内部設計)
   - 開発者の視点からソフトウェア要件をどのように実現すべきかを決定
   - ヒューマンインターフェースの詳細設計、ソフトウェアユニットの機能仕様決定などを行う
   5. 実装・構築(プログラミング)
   6. テスト
4. 運用プロセス
5. 保守プロセス

# アジャイル開発

## XP(エクストリームプログラミング)

- アジャイル開発の手法の一つ
- **イテレーション**という短いサイクル(数週間程度)で動作するプログラムを作成することを繰り返す
- ペアプログラミング：1 人がコーディング、もう 1 人がチェック。役割を交代することでコミュニケーションを円滑にし、品質を保つ
- リファクタリング
- **テスト駆動開発(テストファースト)**：プログラムを書く**前にテストケースを作成**
- **継続的インテグレーション**：コードの結合とテストを継続的に繰り返す

## スクラム開発

- アジャイル開発の手法の一つ
- **ススプリント**と呼ばれる短いサイクル(数週間程度)で動作するプログラムを作成することを繰り返す
- スプリントの始まりの**スプリントプランニング**で作業計画を立てる
- 毎日のミーティング(**デイリースクラム**)で早めの問題解決を図る
- スプリントの終わりの前の**スプリントレビュー**で成果物のレビューを行う
- スプリントの終わりの振り返りの**レトロスペクティブ**で改善事項を検討し、次のスプリントの課題とする

#　スパイラルモデル

- システムをさらに**独立性の高いサブシステムに分割**し、サブシステムごとに要件定義や設計、開発、テストを繰り返しながら段階的にシステムを完成させていく開発手法

# DevOps

- 開発部門と運用部門が協力しながらシステムの改善を進めようという考え方

# オブジェクト指向

## カプセル化

- オブジェクト：密接に関係するデータ(属性)とメソッド(処理)を一体化したもの
- カプセル化：オブジェクトの中身を他オブジェクトから直接アクセスされないように**外部から隠ぺいすること**

## 継承

- スーパークラスで定義しているデータやメソッドをサブクラスに引き継ぐこと
  - オブジェクト指向では既存のクラスを基にして新しいクラスを生成できる
    - 既存のクラス => スーパークラス(基底クラス)
    - 新しく作成したクラス => サブクラス(派生クラス)

## 多態性

- オーバライドすることでインスタンスで同一のメッセージを送っても特有の動作ができるようにすること
- オーバーライド：スーパークラスで定義されたメソッドをそのまま継承するのではなく、サブクラスで再定義することで動作を変更すること
- 移譲：あるオブジェクトに依頼されたメッセージの処理をそのオブジェクトの内部から他のオブジェクトに委ねること

## 抽象化(汎化)

- 線の形ある程度覚えておく(ダイヤとか矢印とかただの線とか)
- 下位クラスの**共通部分を抽出**して上位クラスを定義すること。逆は特化(例：人、犬、猫の 3 クラスから哺乳類クラスを定義)

- 集約-分解：上位クラスが下位クラスの組み合わせで構成されていること

# 業務モデリング

- 業務プロセス(業務の一連の流れ)をヒアリングしながら現状把握や分析を行うこと
- BPR(ビジネスプロセスリエンジニアリング)：業務プロセスを見直し、再設計することで組織の体質や構造を抜本的に変革すること
- BPM(ビジネスプロセスマネジメント)：BPR を一過性のものとせず、PDCA サイクルで**継続的に評価・改善**していくこと

## データフローダイアグラム(DFD)

- 業務プロセスのデータの流れをモデル化したもの。**UML ではない**(見た目は p.405 参照)

## UML

- オブジェクト指向開発の分析から設計・実装・テストまでを統一した表記法でモデル化したもの
- **以下 pp.407-410 の図の実図を参照**
- ユースケース図 => システムが外部に提供する機能と、その利用者や外部システムとの関係を表現した図。機能を**ユースケース**と呼び、**楕円で**システム境界の内部に記述し、利用者の人型を**アクター**と呼び、システム境界の外部に記述
- オブジェクト図 => インスタンス間の関係を示した図
- クラス図
- アクティビティ図 => ある振る舞いからある振る舞いへの制御の流れを表現した図。実行順序や条件分岐、並行処理を表現し、フローチャートと同じようなイメージ
- コミュニケーション図 => オブジェクト間で送受信されるメッセージを示した図で、**オブジェクト同士の関係**の観点からメッセージを表現
- シーケンス図 => オブジェクト間で送受信されるメッセージを示した図で、**時系列**の観点からメッセージを表現

# ヒューマンインターフェース

- 利用者とコンピュータの接点

## 画面設計・帳簿設計

### 画面設計

- パンくずリスト
  - Web サイトによくある、トップページからそのページへの経路情報を示すリスト
  - 例： 書籍案内>>書籍ジャンル>>ライトノベル>>基本情報戦記

### GUI

- ラジオボタン => **排他的な**まるいやつ
- チェックボックス => 四角いチェック付けるやつ。複数選択もいける
- スピンボタン => 平たい上ボタンと下ボタンが縦に並んでついてて、クリックするたびに数値が増減するやつ
- プルダウンメニュー => 住所の都道府県や市区町村の選択でよく使われている、クリックすると縦に広がるやつ
- ポップアップメニュー => 右クリックで出てくるような、画面から浮き出るように表示されるメニュー
- **コンボボックス** => 選択項目にないものはテキストボックスに入力する、テキストボックスとプロダウンメニューをまとめたもの

### シグニファイア

- リンクが青に下線であるように、**その物体に対してできることを示す手がかりのこと**

## 入力チェック

- ニューメリックチェック：**数値として扱う**必要のあるデータに文字などの数値として扱えないものが含まれていないか検査
- シーケンスチェック：データが昇順や降順など、**決められた順番**に並んでいるかどうかをチェックする
- 重複チェック
- フォーマットチェック
- 論理チェック：データが論理的に矛盾がないか検査(例：入力された注文日が入力日以前か)
- リミットチェック：データが**一定の範囲内に**あるか検査
- 照合チェック：データがファイルに存在するかどうか検査

### チェックディジット検査

- 入力データの数値から一定の規則に従って検査文字(**チェックディジット**)を求め、検査文字を入力データの末尾に付加することで、**入力データに誤りがないかどうか検査する**方法

## ユニバーサルデザイン

- **誰もが使える**設計(国籍年齢性別身体的特徴不問)
- アクセシビリティ：誰もが情報サービスを**支障なく操作または利用できる度合い**。「使えない」を「使える」に
- ユーザビリティ：ストレスを感じずに**目標とする要求が達成できる度合い**。「使える」から「使いやすい」に。満足度の評価に実際に利用者と会話する**インタビュー法**を用いる

## UX

- 使いやすさや機能性が要求される**UI にとどまらず**、製品やサービスから得られる**体験**までを含んだ考え方

# モジュール分割

- 以下中見出し二つは p.419 の表参照

## モジュール強度

- 一つのモジュール内に含まれる機能間の関連性の度合い。モジュール強度が強いほどモジュールの独立性が強くなる
- 機能的強度：単一の独立した機能だけをもつ(**最も強度が強い**)
- 暗号的強度：複数の機能を持つが特別な関連性がない(**最も強度が弱い**)

## モジュール結合度

- 複数のモジュールの結合の度合い
- モジュール結合度が弱いほどモジュールの独立性が高くなる
- 以下上から順に結合度が弱く独立性が高い順
- データ結合：データを引数としてモジュール間で受け渡しをする
- スタンプ結合：データ構造を引数としてモジュール間で受け渡しする
- 制御結合：制御パラメタを引数としてモジュール間で受け渡しする
- 外部結合：外部宣言したデータを複数のモジュールが参照する
- 共通結合：外部宣言したデータ構造を複数のモジュールが参照する
- 内容結合：他のモジュール内にあるデータを参照する

## 構造化設計

- システムの機能に着目して、ソフトウェア開発の上位レベルの大きな機能から段階的に詳細化していく設計手法
  - システム設計：システムを**サブシステム**(機能)に分割
  - ソフトウェア要素の設計：サブシステムを**コンポーネント**(ソフトウェア要素:ある機能を実現するために部品化されたプログラム)に分割
  - モジュールの設計：コンポーネントを**モジュール**(プログラムを構成する最小単位)に分割

# テスト手法

## プログラムテスト

- 信頼度成長曲線(ゴンペルツ曲線)：テスト開始後からの累積バグ件数を表すグラフ。
- バグ管理図：バグ検出数、未消化テスト項目数、未解決バグ数の曲線がある(詳しくは p.422 参照)。3 つの推移がすべて**横ばいになった場合は解決困難なバグに直面している可能性**があるので要確認

## テスト工程

- 各設計工程で定義したテスト仕様に基づいてテストケースを準備して実施
  - ソフトウェア設計 => **ソフトウェア統合テスト**・**ソフトウェアユニットテスト(単体テスト)**
  - システム設計 => **システム統合テスト(結合テスト)**
  - ソフトウェア要件定義 => **ソフトウェア検証テスト**
  - システム要件定義 => **システム検証テスト**
  - 要件定義 => **受入れテスト**・**運用テスト**

### ソフトウェアユニットテスト(単体テスト)

- プログラムを構成するモジュール単位に行うテスト
- ホワイトボックステスト：モジュールの内部構造に着目(下記網羅については pp.424-425 参照)
  - 命令網羅
  - 分岐網羅
  - 条件網羅：各条件式の真と偽の組み合わせを少なくとも 1 回以上確認
  - 複数条件網羅：各条件式の真と偽の組み合わせを全て確認
- ブラックボックステスト：モジュールの外部仕様に着目
  - 限界地分析
  - 同値分析

### ソフトウェア統合テスト(結合テスト)

- ソフトウェアユニットテスト(単体テスト)が完了したモジュール同士を結合して行うテスト
- トップダウンテスト
  - 上位モジュールから買いモジュールへと順次結合してインターフェースを確認するテスト
  - 買いモジュールが完成していない場合は仮置きの**スタブ**が必要
- ボトムアップテスト
  - 下位モジュールから上位モジュールへと順次結合してインターフェースを確認するテスト
  - 上位モジュールが完成していない場合は仮置きの**ドライバ**が必要

### システム結合テスト

- 開発者がハードウェアやソフトウェア、手作業さらには関連する他のシステムを結合して動作するかを確認

### ソフトウェア検証テスト

- 開発者が利用者が要求するソフトウェア要件を満たしているかを確認

### システム検証テスト

- 開発者が、実際に業務で使うデータや業務上例外として処理されるデータなどを使い、利用者が要求するシステム要件を満たしているか確認

### 運用テスト・受入れテスト

- システム本番移行直前に**最終利用者(業務担当者)**が行うテスト

## ソフトウェア保守

- 本番稼働中のソフトウェアに対するバグの修正や新しい要件に対応すること
- **リグレッションテスト**(退行テスト)：プログラムの修正や改修によって影響を受けるはずのない箇所に影響を及ぼしていないか確認するテスト

# ソフトウェアの品質特性

- 機能性：仕様書通りに操作でき、正しく動作すること
- 使用性：利用者にとって、理解や習得、操作しやすいこと
- 信頼性：必要な時に使用できること。また、故障時には速やかに回復できること
- 効率性：応答時間や処理時間、信頼性など求められる性能が備わっていること
- 保守性：プログラムの修正がしやすいこと
- 移植性：ある環境から別の環境へ移しやすいこと
