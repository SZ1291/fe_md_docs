# 配列と連結リスト

## 配列

### 特長(配列)

1. 連続領域に**順番通りに格納**
2. 総データ数は先に決定(無駄な領域も発生)
3. データの挿入・削除には後ろのデータもずらす必要があるので**処理時間大**
4. 要素番号でデータに**すぐアクセス可能**

## 連結リスト

### 概要

- 連結リスト：**データを記録するデータ部**と**データの格納位置を示すポインタ部**で構成されるデータ構造
  - 単方向リスト：次のデータへのポインタをもって理宇
  - 双方向リスト：次のデータへのポインタと、前のデータへのポインタを持っている
  - 環状リスト：ポインタをたどり、データが環状に連結されている

### 特長(連結リスト)

1. **非連続領域・非順番通り**でも格納可能
2. 総データ数は**柔軟に変更可能**
3. **前後のポインタのみ修整**するので**処理時間小**
4. ポインタをたどるのでデータへのアクセスは**遅い**

# 木構造(ツリー構造)

## 各部の名称

- 根：一番上(根本)の節(ルート)
- 節：値のこと(ノード)
- 葉：最下位の節(リーフ)
- 枝：節と節の間(ブランチ)
- 親：上位の節
- 子：下位の節
- 部分木：節にぶら下がっている部分
  - 左部分木
  - 右部分木

## 2 分木

- 全ての枝の分岐が二つ以下である木構造

### 完全 2 分木

- 根から葉までの深さがすべて等しい 2 分木
- 例外的に深さが等しくなくても深さの差が 1 以下かつ木全体の左から詰められているものも完全 2 分木とする

### 2 分探索木

- 各節の値が左の子及びその子孫に割り振る値より大きく、かつ右の子及びその子孫に割り振る値より小さくするというルールに従った 2 分木
- p.185 下部参照(特に A6 の節の部分の規則性を忘れがち)
- p.188 上部の練習問題で実際に作る

### ヒープ木

- 全ての節で親＜子または親＞子の関係を持った完全 2 分木

## 逆ポーランド記法

- ポーランド記法は普段高校生以下や文系大学生および一般社会人が書いている計算式の記法
- 「CBA+×」は (B + A)C
- 「ABC×+」は BC + A
- コンピュータの計算は**逆ポーランド記法とスタック**を組み合わせて行う

# ソート(整列)

- 昇順：データを値の小さなものから大きなものへと並び替える
- 降順：データを値の大きなものから小さなものへ並び替える
- n,N：基本的に要素数を示すことが多い。オーダ量の公式では「n」、フローチャートでは「N」にしているのもよく見かける。しかし特に決まっているわけではなさそうなので思い込み注意

## バブルソート(基本交換法)

- **隣り合う**データを比較し、逆順であれば交換していく整列法
- フローチャートは p.191 下部参照

## 選択ソート(基本選択法)

- データ列の最小値(または最大値)を選択して交換し、次にそれを除いた部分の中から最小値(または最大値)を選択して交換していく整列法
- 値をすべてチェックしたら最小値(または最大値)と順番が確定していない最も左(または右)の値を交換する
- フローチャートは p.193 下部を参照

## 挿入ソート(基本挿入法)

- すでに整列済みのデータ列の正しい位置に、データを挿入していく整列法(説明が無地かしいので p.194 の図参照)
- フローチャートは p.195 参照

## シェルソート(改良挿入法)

- 改良したシェルソート
- ある一定間隔おきに取り出した要素内で基本挿入法を用いて整列させ、間隔を詰めながら、間隔が 1 になるまで繰り替えしていく整列法

## クイックソート

- 適当な基準値を決めて「基準値より小さい値」のグループと「基準値より大きい値」のグループに分ける操作を繰り返していく整列法

## ヒープソート

- 見整列の部分を順序木に構成し、その最大値(または最小値)を取り出す操作を繰り返していく整列法

# データの探索

## 線形探索法

- 配列の先頭から順番に目的のデータを探索していく方法

### 番兵法

- 線形探索法を一工夫したもの
- 探索したい目的のデータを列の最後尾に付ける
- 繰り返しの中で「目的のデータか」の判定を行うだけで済み、効率が良くなる

## 2 分探索法

- 探索範囲を半分に絞り込みながら目的のデータを探索する方法

# アルゴリズムの計算量

- オーダ：アルゴリズムの計算量
- オーダ記法
  - 線形探索法 O(n)
  - 2 分探索法 O(log2n) <= 「2」は小さくないが底
  - ハッシュ探索法(1)

# プログラムの性質

- リロケータブル(再配置可能)：主記憶上の**どのアドレスに配置しても**実行できる。プログラムの先頭アドレスを規定レジスタに設定し、プログラムの先頭からの相対アドレスを用いることでプログラムを変更せずに主記憶上の任意のアドレスに配置できる。
- リエントラント(再入可能)：**同時に複数のタスクが共有して実行しても正しい結果がえられる**。歳入可能な処理を実現するには、プログラムを手続き部分とデータ部分に分割し、データ部分をタスク(プロセス)ごとに持つ必要がある。
- リユーザブル(再使用可能)：**位置簿実行した後、ロードしなおさずに再び実行を繰り返しても、正しい結果が得られる**。再使用可能な処理を実現するには、プログラム終了後に、プログラム中で使用している変数の値を初期値に戻す必要がある。
- リカーシブ(再帰的)：**実行中に自分自身を呼び出せる**。再帰的な、実行途中の状態をスタックを用いて LIFO 方式で記録し、制御する必要がある。

# プログラム言語とマークアップ言語

## プログラムの実行手順

- プログラムの実行には**コンパイラ**、**リンカ**、**ローダ**というプログラムを用いる
- コンパイル
  - コンパイラを用いて**原始プログラムから目的プログラム**を生成すること
  - 実行時の処理効率を高めたオブジェクトコードを生成し、プログラムの実行時間を短縮することがコンパイラによる最適化の目的
- リンク(連係編集)
  - リンカ(リンケージエディタ)と呼ばれるプログラムを用いて**複数の目的プログラムなどから一つのロードモジュール(実行可能プログラム)を生成する**こと
  - よく使われる処理をまとめ汎用的に使えるようにしたライブラリモジュールなどもここでリンクされる
  - 動的リンキング：アプリケーションの実行中に必要となったモジュールを OS によって連携する方式
  - 静的リンキング：アプリケーションの実行に先立ってあらかじめ複数のプログラムをリンクしておく方式(リンクの話はこれのこと)
- ロード：ローだを用いて**実行に先立ってロードモジュールを主記憶にロードする**

## その他の言語プロセッサ

- プリコンパイラ：コンパイラが解釈できない高水準言語に付加的に定義された機能やプログラムをコンパイラの前処理で解釈でいるように変換する
- クロスコンパイラ：実際に実行するコンピュータとは命令形式が異なるコンピュータで目的プログラムを生成する
- ジェネレータ：入力・処理・出力などのパラメータを指定することで自動的にプログラムを生成する
- トランスレータ：原始プログラムをを、ある言語から別の言語に変換する
- エミュレータ：他のコンピュータ用に開発されたプログラムを疑似的に実行する

# 形式言語

- 特定の目的のために人為的に作られた言語

## BNF 記法

- プログラム言語の構文を定義する再帰的な言語
- 「左辺::=右辺」左辺は右辺と定義する
- 「|」または
- 「＜記号＞」置き換えできる

## 正規表現

- 文字列の集合の規則を表す記法
- 「.」任意の 1 文字
- 「\*」直前の文字を 0 回以上繰り返す
- 「|」または
- 「[-]」[]内のいずれかの文字
- 「+」直前の文字を 1 回以上繰り返す
